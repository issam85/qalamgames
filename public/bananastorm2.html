<!DOCTYPE html>
<html lang="nl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Banana Storm Survivor</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            -webkit-tap-highlight-color: transparent;
        }
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            overflow: hidden;
            touch-action: none;
        }
        #gameContainer {
            position: relative;
            box-shadow: 0 20px 60px rgba(0,0,0,0.4);
            border-radius: 12px;
            overflow: hidden;
            flex-shrink: 0;
        }
        body.mobile #gameContainer {
            border-radius: 0;
            box-shadow: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
        }
        canvas {
            display: block;
            background: #50b465;
        }
        #ui {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            padding: 8px 12px;
            pointer-events: none;
            color: white;
            font-weight: bold;
            text-shadow: 1px 1px 3px rgba(0,0,0,0.7);
            background: rgba(0,0,0,0.45);
            display: flex;
            align-items: center;
            gap: 12px;
            flex-wrap: nowrap;
            overflow: hidden;
        }
        #scoreDisplay { font-size: 14px; white-space: nowrap; flex-shrink: 0; }
        #levelDisplay { font-size: 14px; color: #ffd700; white-space: nowrap; flex-shrink: 0; }
        #weaponDisplay { font-size: 13px; color: #ff69b4; white-space: nowrap; flex-shrink: 1; overflow: hidden; text-overflow: ellipsis; }
        #healthBar {
            width: 120px;
            min-width: 60px;
            height: 16px;
            background: rgba(0,0,0,0.5);
            border-radius: 8px;
            overflow: hidden;
            border: 2px solid rgba(255,255,255,0.3);
            flex-shrink: 0;
        }
        #healthFill {
            height: 100%;
            background: linear-gradient(90deg, #ff4444 0%, #44ff44 100%);
            transition: width 0.3s ease;
            box-shadow: inset 0 2px 4px rgba(255,255,255,0.3);
        }
        #gameOverScreen {
            position: absolute;
            top: 0; left: 0;
            width: 100%; height: 100%;
            background: rgba(0,0,0,0.85);
            display: none;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            color: white;
            backdrop-filter: blur(5px);
        }
        #gameOverScreen.active { display: flex; }
        #gameOverScreen h1 {
            font-size: 56px;
            margin-bottom: 16px;
            color: #ff6b6b;
            text-shadow: 3px 3px 6px rgba(0,0,0,0.5);
        }
        #gameOverScreen p { font-size: 24px; margin-bottom: 24px; }
        #restartBtn {
            padding: 14px 36px;
            font-size: 22px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            border-radius: 50px;
            cursor: pointer;
            pointer-events: all;
            transition: transform 0.2s, box-shadow 0.2s;
            box-shadow: 0 4px 15px rgba(0,0,0,0.3);
        }
        #restartBtn:hover { transform: translateY(-2px); }
        #restartBtn:active { transform: translateY(0); }
        #instructions {
            position: absolute;
            bottom: 16px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0,0,0,0.6);
            padding: 10px 20px;
            border-radius: 10px;
            font-size: 13px;
            color: white;
            text-align: center;
            white-space: nowrap;
        }
        body.mobile #instructions { display: none; }
        /* In-game notification */
        #notification {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0,0,0,0.8);
            color: #ffd700;
            font-size: 22px;
            font-weight: bold;
            padding: 20px 36px;
            border-radius: 16px;
            text-align: center;
            pointer-events: none;
            display: none;
            z-index: 50;
            border: 2px solid #ffd700;
        }
        /* Joystick */
        #joystick-container {
            display: none;
            position: fixed;
            bottom: 40px;
            left: 40px;
            width: 120px;
            height: 120px;
            z-index: 30;
        }
        #joystick-base {
            width: 120px;
            height: 120px;
            border-radius: 50%;
            background: rgba(255,255,255,0.15);
            border: 3px solid rgba(255,255,255,0.4);
            position: absolute;
            top: 0; left: 0;
        }
        #joystick-thumb {
            width: 50px;
            height: 50px;
            border-radius: 50%;
            background: rgba(255,255,255,0.7);
            box-shadow: 0 4px 15px rgba(0,0,0,0.3);
            position: absolute;
            top: 35px; left: 35px;
            pointer-events: none;
        }
        /* Right joystick (shoot) */
        #joystick-right-container {
            display: none;
            position: fixed;
            bottom: 40px;
            right: 40px;
            width: 120px;
            height: 120px;
            z-index: 30;
        }
        #joystick-right-base {
            width: 120px;
            height: 120px;
            border-radius: 50%;
            background: rgba(255,100,100,0.15);
            border: 3px solid rgba(255,150,150,0.4);
            position: absolute;
            top: 0; left: 0;
        }
        #joystick-right-thumb {
            width: 50px;
            height: 50px;
            border-radius: 50%;
            background: rgba(255,150,150,0.7);
            box-shadow: 0 4px 15px rgba(0,0,0,0.3);
            position: absolute;
            top: 35px; left: 35px;
            pointer-events: none;
        }
        /* Mobile action buttons */
        #mobile-buttons {
            display: none;
            position: fixed;
            bottom: 180px;
            right: 30px;
            z-index: 30;
            flex-direction: column;
            gap: 12px;
            align-items: flex-end;
        }
        .mob-btn {
            width: 64px;
            height: 64px;
            border-radius: 50%;
            border: 3px solid rgba(255,255,255,0.5);
            background: rgba(0,0,0,0.45);
            color: white;
            font-size: 24px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            user-select: none;
            -webkit-user-select: none;
        }
        .mob-btn:active { background: rgba(255,255,255,0.3); }
        /* Landscape hint */
        #landscape-hint {
            display: none;
            position: fixed;
            inset: 0;
            background: rgba(0,0,0,0.9);
            z-index: 100;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            font-size: 1.4em;
            text-align: center;
            color: white;
            padding: 30px;
        }
        #landscape-hint .rotate-icon {
            font-size: 4em;
            margin-bottom: 20px;
            animation: rotateHint 2s infinite;
        }
        @keyframes rotateHint {
            0%, 100% { transform: rotate(0deg); }
            50% { transform: rotate(90deg); }
        }
    </style>
</head>
<body>
    <div id="landscape-hint">
        <div class="rotate-icon">ðŸ“±</div>
        <p>Draai je telefoon horizontaal voor de beste ervaring</p>
    </div>
    <div id="gameContainer">
        <canvas id="gameCanvas"></canvas>
        <div id="ui">
            <div id="scoreDisplay">Score: 0</div>
            <div id="levelDisplay">Level: 1</div>
            <div id="weaponDisplay">Wapen: Normaal ðŸ”«</div>
            <div id="danceDisplay" style="font-size:13px;color:#ff88ff;white-space:nowrap;flex-shrink:0;">ðŸ’ƒ klaar!</div>
            <div id="healthBar">
                <div id="healthFill" style="width:100%"></div>
            </div>
        </div>
        <div id="notification"></div>
        <div id="gameOverScreen">
            <h1>GAME OVER</h1>
            <p id="finalScore">Score: 0</p>
            <button id="restartBtn">Opnieuw Spelen</button>
        </div>
        <div id="instructions">
            WASD - Bewegen | Spatie - Springen ðŸ¦˜ | E - Dansen ðŸ’ƒ / Schatkist ðŸ’Ž | Muis - Schieten | Blijf binnen de storm!
        </div>
    </div>
    <div id="joystick-container">
        <div id="joystick-base"></div>
        <div id="joystick-thumb"></div>
    </div>
    <div id="joystick-right-container">
        <div id="joystick-right-base"></div>
        <div id="joystick-right-thumb"></div>
    </div>
    <div id="mobile-buttons">
        <div class="mob-btn" id="btn-chest">ðŸ’Ž</div>
        <div class="mob-btn" id="btn-dance">ðŸ’ƒ</div>
        <div class="mob-btn" id="btn-jump">ðŸ¦˜</div>
    </div>
    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const GAME_W = 900;
        const GAME_H = 600;
        canvas.width = GAME_W;
        canvas.height = GAME_H;
        // --- Device detection & scaling ---
        const isMobile = ('ontouchstart' in window) && window.innerWidth <= 1024;
        if (isMobile) {
            document.body.classList.add('mobile');
            document.getElementById('joystick-container').style.display = 'block';
            document.getElementById('joystick-right-container').style.display = 'block';
            document.getElementById('mobile-buttons').style.display = 'flex';
        }
        function resizeGame() {
            const w = window.innerWidth;
            const h = window.innerHeight;
            const s = Math.min(w / GAME_W, h / GAME_H);
            const scaledW = GAME_W * s;
            const scaledH = GAME_H * s;
            canvas.style.width = scaledW + 'px';
            canvas.style.height = scaledH + 'px';
            if (isMobile) {
                canvas.style.position = 'absolute';
                canvas.style.left = ((w - scaledW) / 2) + 'px';
                canvas.style.top = ((h - scaledH) / 2) + 'px';
                checkOrientation();
            } else {
                const container = document.getElementById('gameContainer');
                container.style.width = scaledW + 'px';
                container.style.height = scaledH + 'px';
            }
        }
        function checkOrientation() {
            if (!isMobile) return;
            document.getElementById('landscape-hint').style.display =
                window.innerHeight > window.innerWidth ? 'flex' : 'none';
        }
        window.addEventListener('resize', resizeGame);
        window.addEventListener('orientationchange', () => setTimeout(resizeGame, 300));
        document.addEventListener('touchstart', e => e.preventDefault(), { passive: false });
        document.addEventListener('touchmove', e => e.preventDefault(), { passive: false });
        // --- Joystick ---
        const joystickContainer = document.getElementById('joystick-container');
        const joystickThumb = document.getElementById('joystick-thumb');
        const JOYSTICK_RADIUS = 60;
        const DEAD_ZONE = 10;
        let joystick = { active: false, startX: 0, startY: 0, dx: 0, dy: 0 };
        let joystickRight = { active: false, startX: 0, startY: 0, dx: 0, dy: 0 };
        let shootInterval = null;
        if (isMobile) {
            joystickContainer.addEventListener('touchstart', e => {
                e.preventDefault();
                e.stopPropagation();
                const t = e.touches[0];
                joystick.active = true;
                joystick.startX = t.clientX;
                joystick.startY = t.clientY;
                joystick.dx = 0;
                joystick.dy = 0;
            });
            window.addEventListener('touchmove', e => {
                if (!joystick.active && !joystickRight.active) return;
                e.preventDefault();
                if (!joystick.active) return;
                const t = e.touches[0];
                let dx = t.clientX - joystick.startX;
                let dy = t.clientY - joystick.startY;
                const dist = Math.sqrt(dx * dx + dy * dy);
                if (dist > JOYSTICK_RADIUS) {
                    dx = (dx / dist) * JOYSTICK_RADIUS;
                    dy = (dy / dist) * JOYSTICK_RADIUS;
                }
                joystick.dx = dx;
                joystick.dy = dy;
                joystickThumb.style.left = (35 + dx) + 'px';
                joystickThumb.style.top = (35 + dy) + 'px';
            });
            window.addEventListener('touchend', e => {
                joystick.active = false;
                joystick.dx = 0;
                joystick.dy = 0;
                joystickThumb.style.left = '35px';
                joystickThumb.style.top = '35px';
            });
            // Right joystick: shoot direction
            const rjContainer = document.getElementById('joystick-right-container');
            const rjThumb = document.getElementById('joystick-right-thumb');
            rjContainer.addEventListener('touchstart', e => {
                e.preventDefault();
                e.stopPropagation();
                const t = e.touches[0];
                joystickRight.active = true;
                joystickRight.startX = t.clientX;
                joystickRight.startY = t.clientY;
                joystickRight.dx = 0;
                joystickRight.dy = 0;
                clearInterval(shootInterval);
                shootInterval = setInterval(() => {
                    if (!gameOver && !isDancing && joystickRight.active) {
                        const dist = Math.sqrt(joystickRight.dx * joystickRight.dx + joystickRight.dy * joystickRight.dy);
                        if (dist > DEAD_ZONE) {
                            const angle = Math.atan2(joystickRight.dy, joystickRight.dx);
                            player.angle = angle;
                            shootAt(player.x + Math.cos(angle) * 200, player.y + Math.sin(angle) * 200);
                        }
                    }
                }, 250);
            });
            window.addEventListener('touchmove', e => {
                if (!joystickRight.active) return;
                for (let i = 0; i < e.touches.length; i++) {
                    const t = e.touches[i];
                    let dx = t.clientX - joystickRight.startX;
                    let dy = t.clientY - joystickRight.startY;
                    const dist = Math.sqrt(dx * dx + dy * dy);
                    if (dist > JOYSTICK_RADIUS) {
                        dx = (dx / dist) * JOYSTICK_RADIUS;
                        dy = (dy / dist) * JOYSTICK_RADIUS;
                    }
                    joystickRight.dx = dx;
                    joystickRight.dy = dy;
                    rjThumb.style.left = (35 + dx) + 'px';
                    rjThumb.style.top = (35 + dy) + 'px';
                    break;
                }
            });
            window.addEventListener('touchend', e => {
                if (joystickRight.active) {
                    joystickRight.active = false;
                    joystickRight.dx = 0;
                    joystickRight.dy = 0;
                    rjThumb.style.left = '35px';
                    rjThumb.style.top = '35px';
                    clearInterval(shootInterval);
                    shootInterval = null;
                }
            });
            // Mobile action buttons
            document.getElementById('btn-jump').addEventListener('touchstart', e => {
                e.stopPropagation();
                if (!isJumping && !isDancing) {
                    isJumping = true;
                    jumpVelocity = jumpPower;
                }
            });
            document.getElementById('btn-dance').addEventListener('touchstart', e => {
                e.preventDefault();
                e.stopPropagation();
                activateDance();
            }, { passive: false });
            document.getElementById('btn-chest').addEventListener('touchstart', e => {
                e.stopPropagation();
                keys['e'] = true;
                setTimeout(() => { keys['e'] = false; }, 200);
            });
        }
        // --- Notification helper (replaces alert) ---
        let notifTimeout = null;
        function showNotification(msg, duration = 3000) {
            const el = document.getElementById('notification');
            el.textContent = msg;
            el.style.display = 'block';
            clearTimeout(notifTimeout);
            notifTimeout = setTimeout(() => { el.style.display = 'none'; }, duration);
        }
        // --- Game variables ---
        let player = { x: GAME_W / 2, y: GAME_H / 2, size: 30, speed: 4.5, angle: 0 };
        let bullets = [], enemyBullets = [], enemies = [], particles = [];
        let treasureChests = [], lightningStrikes = [];
        let hasDoubleShot = false, hasSecondGun = false, chestsOpened = 0;
        let lightningEffect = { active: false, time: 0, duration: 120 };
        let score = 0, gameOver = false, level = 1, health = 100;
        let stormRadius = 380, stormShrink = 0.02, wobble = 0;
        let enemySpawnInterval, enemyShootInterval;
        let mousePos = { x: 0, y: 0 };
        let keys = {};
        let isDancing = false, danceTime = 0;
        let danceActive = false, danceTimer = 0, danceCooldown = 0;
        const DANCE_DURATION = 3, DANCE_COOLDOWN = 8, DANCE_RADIUS = 120;
        let isJumping = false, jumpHeight = 0, jumpVelocity = 0;
        const jumpPower = 15, gravity = 0.8;
        let camera = { x: 0, y: 0, targetX: 0, targetY: 0, smoothing: 0.1 };
        function shootAt(worldX, worldY) {
            const angle = Math.atan2(worldY - player.y, worldX - player.x);
            if (hasDoubleShot && hasSecondGun) {
                const spread = 0.15;
                bullets.push({ x: player.x, y: player.y, vx: Math.cos(angle - spread) * 8, vy: Math.sin(angle - spread) * 8, life: 100 });
                bullets.push({ x: player.x, y: player.y, vx: Math.cos(angle + spread) * 8, vy: Math.sin(angle + spread) * 8, life: 100 });
                bullets.push({ x: player.x, y: player.y, vx: Math.cos(angle) * 8, vy: Math.sin(angle) * 8, life: 100 });
            } else if (hasDoubleShot) {
                const spread = 0.15;
                bullets.push({ x: player.x, y: player.y, vx: Math.cos(angle - spread) * 8, vy: Math.sin(angle - spread) * 8, life: 100 });
                bullets.push({ x: player.x, y: player.y, vx: Math.cos(angle + spread) * 8, vy: Math.sin(angle + spread) * 8, life: 100 });
            } else {
                bullets.push({ x: player.x, y: player.y, vx: Math.cos(angle) * 8, vy: Math.sin(angle) * 8, life: 100 });
            }
        }
        function activateDance() {
            if (danceActive || danceCooldown > 0 || gameOver) return;
            danceActive = true;
            isDancing = true;
            danceTimer = DANCE_DURATION;
            updateUI();
        }
        function init() {
            resetGame();
            startEnemySpawner();
            startEnemyShooting();
            setTimeout(() => {
                spawnTreasureChest();
                setInterval(() => {
                    if (!gameOver && treasureChests.filter(c => !c.isOpen).length < 2) {
                        spawnTreasureChest();
                    }
                }, 15000);
            }, 5000);
            resizeGame();
            gameLoop();
        }
        function resetGame() {
            danceActive = false; danceTimer = 0; danceCooldown = 0; isDancing = false;
            player = { x: GAME_W / 2, y: GAME_H / 2, size: 30, speed: 4.5, angle: 0 };
            bullets = []; enemyBullets = []; enemies = []; particles = [];
            treasureChests = []; lightningStrikes = [];
            hasDoubleShot = false; hasSecondGun = false; chestsOpened = 0;
            lightningEffect = { active: false, time: 0, duration: 120 };
            score = 0; health = 100; stormRadius = 380; gameOver = false; level = 1;
            camera.x = player.x - GAME_W / 2;
            camera.y = player.y - GAME_H / 2;
            camera.targetX = camera.x;
            camera.targetY = camera.y;
            updateUI();
            document.getElementById('gameOverScreen').classList.remove('active');
        }
        function startEnemySpawner() {
            clearInterval(enemySpawnInterval);
            enemySpawnInterval = setInterval(() => { if (!gameOver) spawnEnemy(); }, 1400);
        }
        function spawnTreasureChest() {
            const angle = Math.random() * Math.PI * 2;
            const spawnDist = Math.random() * (stormRadius - 100);
            const chestX = GAME_W / 2 + Math.cos(angle) * spawnDist;
            const chestY = GAME_H / 2 + Math.sin(angle) * spawnDist;
            lightningStrikes.push({ x: chestX, y: chestY, time: 0, duration: 90, intensity: 0 });
            setTimeout(() => {
                treasureChests.push({ x: chestX, y: chestY, isOpen: false, sparkleTime: 0 });
            }, 1500);
        }
        function startEnemyShooting() {
            clearInterval(enemyShootInterval);
            enemyShootInterval = setInterval(() => {
                if (!gameOver) {
                    enemies.forEach(enemy => {
                        if (Math.random() < 0.3) {
                            const angle = Math.atan2(player.y - enemy.y, player.x - enemy.x);
                            const spread = (Math.random() - 0.5) * 0.3;
                            enemyBullets.push({ x: enemy.x, y: enemy.y, vx: Math.cos(angle + spread) * 6, vy: Math.sin(angle + spread) * 6, life: 100 });
                        }
                    });
                }
            }, 800);
        }
        function spawnEnemy() {
            enemies.push({ x: Math.random() * GAME_W, y: Math.random() * GAME_H, size: 26, speed: level * 1.1, health: 1 });
        }
        function gameLoop() {
            update();
            draw();
            requestAnimationFrame(gameLoop);
        }
        function getMoveInput() {
            const input = { x: 0, y: 0 };
            if (isMobile) {
                if (Math.abs(joystick.dx) > DEAD_ZONE) input.x = joystick.dx / JOYSTICK_RADIUS;
                if (Math.abs(joystick.dy) > DEAD_ZONE) input.y = joystick.dy / JOYSTICK_RADIUS;
            } else {
                if (keys['w'] || keys['W']) input.y = -1;
                if (keys['s'] || keys['S']) input.y = 1;
                if (keys['a'] || keys['A']) input.x = -1;
                if (keys['d'] || keys['D']) input.x = 1;
            }
            return input;
        }
        function update() {
            if (gameOver) return;
            wobble += 0.1;
            if (danceActive) {
                danceTime += 0.2;
                danceTimer -= 1/60;
                if (danceTimer <= 0) {
                    danceActive = false;
                    isDancing = false;
                    danceCooldown = DANCE_COOLDOWN;
                } else {
                    // Kill enemies in radius
                    for (let i = enemies.length - 1; i >= 0; i--) {
                        if (Math.hypot(player.x - enemies[i].x, player.y - enemies[i].y) < DANCE_RADIUS) {
                            createParticles(enemies[i].x, enemies[i].y, '#c83232');
                            enemies.splice(i, 1);
                            score++;
                        }
                    }
                }
                updateUI();
            } else {
                danceTime = 0;
                if (danceCooldown > 0) {
                    danceCooldown -= 1/60;
                    if (danceCooldown < 0) danceCooldown = 0;
                    updateUI();
                }
            }
            if (isJumping) {
                jumpVelocity -= gravity;
                jumpHeight += jumpVelocity;
                if (jumpHeight <= 0) { jumpHeight = 0; isJumping = false; jumpVelocity = 0; }
            }
            if (!isDancing) {
                const move = getMoveInput();
                player.x += move.x * player.speed;
                player.y += move.y * player.speed;
            }
            player.x = Math.max(player.size, Math.min(GAME_W - player.size, player.x));
            player.y = Math.max(player.size, Math.min(GAME_H - player.size, player.y));
            camera.targetX = player.x - GAME_W / 2;
            camera.targetY = player.y - GAME_H / 2;
            camera.x += (camera.targetX - camera.x) * camera.smoothing;
            camera.y += (camera.targetY - camera.y) * camera.smoothing;
            if (!isMobile) {
                player.angle = Math.atan2((mousePos.y + camera.y) - player.y, (mousePos.x + camera.x) - player.x);
            }
            bullets.forEach((b, i) => {
                b.x += b.vx; b.y += b.vy; b.life--;
                if (b.life <= 0 || b.x < 0 || b.x > GAME_W || b.y < 0 || b.y > GAME_H) bullets.splice(i, 1);
            });
            enemyBullets.forEach((b, i) => {
                b.x += b.vx; b.y += b.vy; b.life--;
                if (b.life <= 0 || b.x < 0 || b.x > GAME_W || b.y < 0 || b.y > GAME_H) { enemyBullets.splice(i, 1); return; }
                if (Math.hypot(player.x - b.x, player.y - b.y) < player.size) {
                    enemyBullets.splice(i, 1);
                    health -= 5;
                    createParticles(player.x, player.y, '#ffe650');
                    if (health <= 0) { health = 0; gameOver = true; showGameOver(); }
                    updateUI();
                }
            });
            enemies.forEach((enemy, i) => {
                const angle = Math.atan2(player.y - enemy.y, player.x - enemy.x);
                enemy.x += Math.cos(angle) * enemy.speed;
                enemy.y += Math.sin(angle) * enemy.speed;
                if (Math.hypot(player.x - enemy.x, player.y - enemy.y) < player.size + enemy.size / 2 && jumpHeight < 30) {
                    gameOver = true; showGameOver();
                }
                bullets.forEach((bullet, j) => {
                    if (Math.hypot(bullet.x - enemy.x, bullet.y - enemy.y) < enemy.size) {
                        createParticles(enemy.x, enemy.y, '#c83232');
                        enemies.splice(i, 1);
                        bullets.splice(j, 1);
                        score++;
                        updateUI();
                    }
                });
            });
            particles.forEach((p, i) => {
                p.x += p.vx; p.y += p.vy; p.life--; p.alpha -= 0.02;
                if (p.life <= 0 || p.alpha <= 0) particles.splice(i, 1);
            });
            stormRadius -= stormShrink;
            if (stormRadius < 120) stormRadius = 120;
            if (Math.hypot(player.x - GAME_W / 2, player.y - GAME_H / 2) > stormRadius) {
                health -= 0.15;
                if (health <= 0) { health = 0; gameOver = true; showGameOver(); }
                updateUI();
            }
            treasureChests.forEach(chest => {
                chest.sparkleTime += 0.1;
                if (Math.hypot(player.x - chest.x, player.y - chest.y) < 50 && !chest.isOpen && keys['e']) {
                    chest.isOpen = true;
                    chestsOpened++;
                    if (chestsOpened === 1) hasDoubleShot = true;
                    else if (chestsOpened === 2) hasSecondGun = true;
                    lightningEffect.active = true;
                    lightningEffect.time = 0;
                    for (let i = 0; i < 30; i++) {
                        const a = (Math.PI * 2 / 30) * i;
                        particles.push({ x: chest.x, y: chest.y, vx: Math.cos(a) * (5 + Math.random() * 3), vy: Math.sin(a) * (5 + Math.random() * 3), r: 255, g: 215 + Math.random() * 40, b: 0, alpha: 1, life: 40 + Math.random() * 20 });
                    }
                    updateUI();
                }
            });
            lightningStrikes = lightningStrikes.filter(strike => {
                strike.time++;
                strike.intensity = Math.sin(strike.time * 0.3) * 0.5 + 0.5;
                if (Math.random() < 0.3) {
                    const a = Math.random() * Math.PI * 2;
                    particles.push({ x: strike.x + Math.cos(a) * Math.random() * 30, y: strike.y + Math.sin(a) * Math.random() * 30, vx: (Math.random() - 0.5) * 2, vy: -Math.random() * 3 - 2, r: 200 + Math.random() * 55, g: 200 + Math.random() * 55, b: 255, alpha: 1, life: 20 + Math.random() * 10 });
                }
                return strike.time < strike.duration;
            });
            if (lightningEffect.active) {
                lightningEffect.time++;
                if (lightningEffect.time >= lightningEffect.duration) lightningEffect.active = false;
            }
            if (stormRadius === 120 && level === 1) levelUp();
        }
        function draw() {
            ctx.fillStyle = stormRadius > 120 ? '#50b465' : '#6496ff';
            ctx.fillRect(0, 0, GAME_W, GAME_H);
            if (gameOver) return;
            ctx.save();
            ctx.translate(-camera.x, -camera.y);
            const centerX = GAME_W / 2, centerY = GAME_H / 2;
            const numClouds = 16;
            for (let i = 0; i < numClouds; i++) {
                const angle = (Math.PI * 2 / numClouds) * i + wobble * 0.1;
                const cloudX = centerX + Math.cos(angle) * stormRadius;
                const cloudY = centerY + Math.sin(angle) * stormRadius;
                const off = Math.sin(wobble + i) * 5;
                ctx.fillStyle = 'rgba(100,120,255,0.4)';
                ctx.beginPath(); ctx.arc(cloudX + off, cloudY, 15, 0, Math.PI * 2); ctx.fill();
                ctx.fillStyle = 'rgba(120,140,255,0.5)';
                ctx.beginPath(); ctx.arc(cloudX - 10 + off, cloudY - 5, 12, 0, Math.PI * 2); ctx.fill();
                ctx.beginPath(); ctx.arc(cloudX + 10 + off, cloudY - 5, 12, 0, Math.PI * 2); ctx.fill();
                ctx.fillStyle = 'rgba(80,100,255,0.6)';
                ctx.beginPath(); ctx.arc(cloudX + off, cloudY - 8, 10, 0, Math.PI * 2); ctx.fill();
            }
            ctx.strokeStyle = 'rgba(100,100,255,0.5)';
            ctx.lineWidth = 8;
            ctx.beginPath(); ctx.arc(centerX, centerY, stormRadius, 0, Math.PI * 2); ctx.stroke();
            if (Math.random() < 0.02) {
                const la = Math.random() * Math.PI * 2;
                const lx = centerX + Math.cos(la) * stormRadius;
                const ly = centerY + Math.sin(la) * stormRadius;
                ctx.strokeStyle = 'rgba(200,200,255,0.8)';
                ctx.lineWidth = 3;
                ctx.beginPath();
                ctx.moveTo(lx, ly);
                ctx.lineTo(lx + Math.random() * 40 - 20, ly + 30);
                ctx.lineTo(lx + Math.random() * 40 - 20, ly + 60);
                ctx.stroke();
            }
            particles.forEach(p => {
                ctx.fillStyle = `rgba(${p.r},${p.g},${p.b},${p.alpha})`;
                ctx.fillRect(p.x - 2, p.y - 2, 4, 4);
            });
            enemies.forEach(enemy => {
                ctx.save();
                ctx.translate(enemy.x, enemy.y);
                ctx.shadowBlur = 10; ctx.shadowColor = '#ff0000';
                ctx.fillStyle = '#c83232';
                ctx.fillRect(-enemy.size / 2, -enemy.size / 2, enemy.size, enemy.size);
                ctx.shadowBlur = 0;
                ctx.fillStyle = '#fff';
                ctx.fillRect(-8, -8, 6, 6); ctx.fillRect(2, -8, 6, 6);
                ctx.fillStyle = '#000';
                ctx.fillRect(-6, -6, 3, 3); ctx.fillRect(4, -6, 3, 3);
                const ga = Math.atan2(player.y - enemy.y, player.x - enemy.x);
                ctx.rotate(ga);
                ctx.fillStyle = '#1a1a1a'; ctx.fillRect(enemy.size / 2, -4, 18, 8);
                ctx.fillStyle = '#0a0a0a'; ctx.fillRect(enemy.size / 2 + 18, -3, 8, 6);
                ctx.fillStyle = '#4a4a4a'; ctx.fillRect(enemy.size / 2 - 3, -1, 6, 10);
                ctx.restore();
            });
            lightningStrikes.forEach(strike => {
                const progress = strike.time / strike.duration;
                const alpha = strike.intensity * (1 - progress * 0.3);
                ctx.save();
                ctx.translate(strike.x, strike.y);
                ctx.strokeStyle = `rgba(255,255,100,${alpha * 0.8})`; ctx.lineWidth = 3;
                ctx.beginPath(); ctx.arc(0, 0, 40, 0, Math.PI * 2); ctx.stroke();
                const grd = ctx.createRadialGradient(0, 0, 0, 0, 0, 50);
                grd.addColorStop(0, `rgba(255,255,200,${alpha * 0.4})`);
                grd.addColorStop(0.5, `rgba(255,200,100,${alpha * 0.2})`);
                grd.addColorStop(1, 'rgba(255,200,0,0)');
                ctx.fillStyle = grd; ctx.beginPath(); ctx.arc(0, 0, 50, 0, Math.PI * 2); ctx.fill();
                if (progress < 0.8) {
                    ctx.fillStyle = `rgba(255,255,255,${alpha})`;
                    ctx.font = 'bold 16px Arial'; ctx.textAlign = 'center';
                    ctx.fillText('âš ï¸ SCHATKIST âš ï¸', 0, -60);
                }
                ctx.restore();
            });
            treasureChests.forEach(chest => {
                ctx.save();
                ctx.translate(chest.x, chest.y);
                if (!chest.isOpen) {
                    ctx.fillStyle = '#8B4513'; ctx.fillRect(-20, 0, 40, 25);
                    ctx.fillStyle = '#A0522D'; ctx.fillRect(-22, -12, 44, 15);
                    ctx.fillStyle = '#FFD700'; ctx.fillRect(-5, 5, 10, 8);
                    ctx.fillStyle = '#DAA520'; ctx.beginPath(); ctx.arc(0, 9, 3, 0, Math.PI * 2); ctx.fill();
                    const sparkle = Math.sin(chest.sparkleTime) * 0.5 + 0.5;
                    ctx.fillStyle = `rgba(255,215,0,${sparkle})`;
                    ctx.font = '16px Arial'; ctx.fillText('âœ¨', -25, -15); ctx.fillText('âœ¨', 15, -15);
                    if (Math.hypot(player.x - chest.x, player.y - chest.y) < 50) {
                        ctx.fillStyle = 'white'; ctx.font = 'bold 14px Arial'; ctx.textAlign = 'center';
                        ctx.fillText(isMobile ? 'Druk ðŸ’Ž' : 'Druk E', 0, -25);
                    }
                } else {
                    ctx.fillStyle = '#8B4513'; ctx.fillRect(-20, 0, 40, 25);
                    ctx.fillStyle = '#A0522D';
                    ctx.save(); ctx.rotate(-Math.PI / 3); ctx.fillRect(-22, -27, 44, 15); ctx.restore();
                    ctx.fillStyle = '#654321'; ctx.fillRect(-15, 5, 30, 15);
                }
                ctx.restore();
            });
            bullets.forEach(b => {
                ctx.fillStyle = '#000'; ctx.beginPath(); ctx.arc(b.x, b.y, 4, 0, Math.PI * 2); ctx.fill();
            });
            enemyBullets.forEach(b => {
                ctx.fillStyle = '#ff0000'; ctx.strokeStyle = '#ff6666'; ctx.lineWidth = 2;
                ctx.shadowBlur = 8; ctx.shadowColor = '#ff0000';
                ctx.beginPath(); ctx.arc(b.x, b.y, 5, 0, Math.PI * 2); ctx.fill(); ctx.stroke();
                ctx.shadowBlur = 0;
            });
            drawBanana(player.x, player.y, player.size, player.angle);
            if (danceActive) {
                const progress = danceTimer / DANCE_DURATION;
                const pulse = Math.sin(wobble * 4) * 0.2 + 0.8;
                const auraAlpha = pulse * 0.35;
                const grd = ctx.createRadialGradient(player.x, player.y, 0, player.x, player.y, DANCE_RADIUS);
                grd.addColorStop(0, `rgba(255,100,255,${auraAlpha})`);
                grd.addColorStop(0.6, `rgba(200,50,255,${auraAlpha * 0.5})`);
                grd.addColorStop(1, 'rgba(150,0,255,0)');
                ctx.fillStyle = grd;
                ctx.beginPath(); ctx.arc(player.x, player.y, DANCE_RADIUS, 0, Math.PI * 2); ctx.fill();
                ctx.strokeStyle = `rgba(255,150,255,${pulse * 0.8})`;
                ctx.lineWidth = 3;
                ctx.setLineDash([8, 6]);
                ctx.beginPath(); ctx.arc(player.x, player.y, DANCE_RADIUS, 0, Math.PI * 2); ctx.stroke();
                ctx.setLineDash([]);
            }
            if (lightningEffect.active) {
                const progress = lightningEffect.time / lightningEffect.duration;
                const intensity = Math.sin(lightningEffect.time * 0.3) * 0.3 + 0.7;
                const auraAlpha = (1 - progress) * intensity * 0.4;
                const og = ctx.createRadialGradient(player.x, player.y, 0, player.x, player.y, 80);
                og.addColorStop(0, `rgba(0,255,255,${auraAlpha})`);
                og.addColorStop(0.5, `rgba(100,200,255,${auraAlpha * 0.5})`);
                og.addColorStop(1, 'rgba(0,255,255,0)');
                ctx.fillStyle = og; ctx.beginPath(); ctx.arc(player.x, player.y, 80, 0, Math.PI * 2); ctx.fill();
            }
            ctx.restore();
        }
        function drawBanana(x, y, size) {
            ctx.save();
            const jumpY = y - jumpHeight;
            ctx.translate(x, jumpY);
            let bounce = Math.sin(wobble * 2) * 2;
            let armWave = Math.sin(wobble * 1.5) * 0.2;
            if (isDancing) {
                bounce = Math.sin(danceTime * 3) * 8;
                armWave = Math.sin(danceTime * 4) * 0.8;
                ctx.rotate(Math.sin(danceTime * 2) * 0.3);
            }
            ctx.save();
            ctx.translate(0, jumpHeight);
            ctx.fillStyle = 'rgba(0,0,0,0.2)';
            const sh = Math.max(0.5, 1 - jumpHeight / 100);
            ctx.beginPath(); ctx.ellipse(0, size * 1.8, size * 1.2 * sh, 8 * sh, 0, 0, Math.PI * 2); ctx.fill();
            ctx.restore();
            ctx.strokeStyle = '#e6b400'; ctx.lineWidth = 6; ctx.lineCap = 'round';
            const legSpread = isDancing ? Math.sin(danceTime * 5) * 0.4 : 0;
            ctx.beginPath(); ctx.moveTo(-size * 0.3, size * 0.8); ctx.lineTo(-size * (0.4 + legSpread), size * 1.3 + bounce); ctx.stroke();
            ctx.beginPath(); ctx.moveTo(size * 0.3, size * 0.8); ctx.lineTo(size * (0.4 - legSpread), size * 1.3 + bounce); ctx.stroke();
            ctx.fillStyle = '#ffe650';
            ctx.beginPath(); ctx.ellipse(-size * (0.4 + legSpread), size * 1.3 + bounce, 8, 5, 0, 0, Math.PI * 2); ctx.fill();
            ctx.beginPath(); ctx.ellipse(size * (0.4 - legSpread), size * 1.3 + bounce, 8, 5, 0, 0, Math.PI * 2); ctx.fill();
            ctx.fillStyle = '#ffe650'; ctx.strokeStyle = '#e6b400'; ctx.lineWidth = 4;
            ctx.beginPath(); ctx.ellipse(0, 0, size * 0.8, size * 1.1, 0, 0, Math.PI * 2); ctx.fill(); ctx.stroke();
            ctx.fillStyle = '#fff596';
            ctx.beginPath(); ctx.ellipse(-size * 0.25, 0, size * 0.15, size * 0.9, 0, 0, Math.PI * 2); ctx.fill();
            ctx.beginPath(); ctx.ellipse(size * 0.25, 0, size * 0.15, size * 0.9, 0, 0, Math.PI * 2); ctx.fill();
            ctx.strokeStyle = '#e6b400'; ctx.lineWidth = 5; ctx.lineCap = 'round';
            if (isDancing) {
                const da = Math.sin(danceTime * 4) * 0.5;
                ctx.beginPath(); ctx.moveTo(-size * 0.7, size * 0.2); ctx.quadraticCurveTo(-size * 0.9, -size * 0.5 + da, -size * 0.6, -size * 0.8); ctx.stroke();
                ctx.beginPath(); ctx.moveTo(size * 0.7, size * 0.2); ctx.quadraticCurveTo(size * 0.9, -size * 0.5 - da, size * 0.6, -size * 0.8); ctx.stroke();
                ctx.fillStyle = '#ffe650';
                ctx.beginPath(); ctx.arc(-size * 0.6, -size * 0.8, 6, 0, Math.PI * 2); ctx.fill();
                ctx.beginPath(); ctx.arc(size * 0.6, -size * 0.8, 6, 0, Math.PI * 2); ctx.fill();
            } else {
                ctx.beginPath(); ctx.moveTo(-size * 0.7, size * 0.2); ctx.quadraticCurveTo(-size * 1.1, size * 0.3 + armWave, -size * 0.9, size * 0.6); ctx.stroke();
                ctx.beginPath(); ctx.moveTo(size * 0.7, size * 0.2); ctx.quadraticCurveTo(size * 1.1, size * 0.3 - armWave, size * 0.9, size * 0.6); ctx.stroke();
                ctx.fillStyle = '#ffe650';
                ctx.beginPath(); ctx.arc(-size * 0.9, size * 0.6, 6, 0, Math.PI * 2); ctx.fill();
                ctx.beginPath(); ctx.arc(size * 0.9, size * 0.6, 6, 0, Math.PI * 2); ctx.fill();
            }
            ctx.fillStyle = '#ffe650'; ctx.strokeStyle = '#e6b400'; ctx.lineWidth = 4;
            ctx.beginPath(); ctx.ellipse(0, -size * 0.8, size * 0.6, size * 0.7, 0, 0, Math.PI * 2); ctx.fill(); ctx.stroke();
            ctx.strokeStyle = '#8b6914'; ctx.lineWidth = 3;
            ctx.beginPath(); ctx.moveTo(0, -size * 1.4); ctx.lineTo(size * 0.1, -size * 1.6); ctx.stroke();
            let ex, ey;
            if (isDancing) {
                ex = Math.sin(danceTime * 3) * 2; ey = -2;
            } else if (isMobile) {
                const move = getMoveInput();
                ex = move.x * 3; ey = move.y * 3;
            } else {
                ex = Math.max(-3, Math.min(3, ((mousePos.x + camera.x) - x) / 40));
                ey = Math.max(-3, Math.min(3, ((mousePos.y + camera.y) - y) / 40));
            }
            ctx.fillStyle = '#fff';
            ctx.beginPath(); ctx.ellipse(-size * 0.2 + ex, -size * 0.8 + ey, 7, isDancing ? 5 : 9, 0, 0, Math.PI * 2); ctx.fill();
            ctx.beginPath(); ctx.ellipse(size * 0.2 + ex, -size * 0.8 + ey, 7, isDancing ? 5 : 9, 0, 0, Math.PI * 2); ctx.fill();
            ctx.fillStyle = '#000';
            ctx.beginPath(); ctx.ellipse(-size * 0.2 + ex, -size * 0.8 + ey, 4, isDancing ? 3 : 5, 0, 0, Math.PI * 2); ctx.fill();
            ctx.beginPath(); ctx.ellipse(size * 0.2 + ex, -size * 0.8 + ey, 4, isDancing ? 3 : 5, 0, 0, Math.PI * 2); ctx.fill();
            ctx.strokeStyle = '#000'; ctx.lineWidth = 2.5;
            ctx.beginPath(); ctx.arc(0, -size * 0.65, isDancing ? 10 : 8, 0, Math.PI); ctx.stroke();
            ctx.fillStyle = 'rgba(255,150,150,0.4)';
            ctx.beginPath(); ctx.ellipse(-size * 0.4, -size * 0.7, 6, 4, 0, 0, Math.PI * 2); ctx.fill();
            ctx.beginPath(); ctx.ellipse(size * 0.4, -size * 0.7, 6, 4, 0, 0, Math.PI * 2); ctx.fill();
            if (!isDancing) {
                let gunAngle;
                if (isMobile) {
                    gunAngle = player.angle;
                } else {
                    gunAngle = Math.atan2((mousePos.y + camera.y) - y, (mousePos.x + camera.x) - x);
                }
                ctx.rotate(gunAngle);
                ctx.fillStyle = '#2c3e50'; ctx.fillRect(size * 0.5, -6, 25, 12);
                ctx.fillStyle = '#1a252f'; ctx.fillRect(size * 0.5 + 25, -4, 12, 8);
                ctx.fillStyle = '#8b4513'; ctx.fillRect(size * 0.5 - 5, -2, 8, 15);
                ctx.fillStyle = '#ffd700'; ctx.beginPath(); ctx.arc(size * 0.5 + 5, 8, 3, 0, Math.PI * 2); ctx.fill();
                if (hasSecondGun) {
                    ctx.fillStyle = '#2c3e50'; ctx.fillRect(size * 0.5, -22, 25, 12);
                    ctx.fillStyle = '#1a252f'; ctx.fillRect(size * 0.5 + 25, -20, 12, 8);
                    ctx.fillStyle = '#8b4513'; ctx.fillRect(size * 0.5 - 5, -18, 8, 15);
                    ctx.fillStyle = '#ffd700'; ctx.beginPath(); ctx.arc(size * 0.5 + 5, -8, 3, 0, Math.PI * 2); ctx.fill();
                }
            }
            ctx.restore();
        }
        function createParticles(x, y, color) {
            const rgb = hexToRgb(color);
            for (let i = 0; i < 8; i++) {
                const angle = (Math.PI * 2 / 8) * i;
                particles.push({ x, y, vx: Math.cos(angle) * 3, vy: Math.sin(angle) * 3, r: rgb.r, g: rgb.g, b: rgb.b, alpha: 1, life: 30 });
            }
        }
        function hexToRgb(hex) {
            const r = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
            return r ? { r: parseInt(r[1], 16), g: parseInt(r[2], 16), b: parseInt(r[3], 16) } : { r: 255, g: 255, b: 255 };
        }
        function updateUI() {
            document.getElementById('scoreDisplay').textContent = `Score: ${score}`;
            document.getElementById('levelDisplay').textContent = `Level: ${level}`;
            let wt = 'Wapen: Normaal ðŸ”«';
            if (hasDoubleShot && !hasSecondGun) wt = 'Wapen: Dubbel Schot ðŸ”«ðŸ’¥';
            else if (hasDoubleShot && hasSecondGun) wt = 'Wapen: Dubbel + Tweede Gun ðŸ”«ðŸ’¥ðŸ”«';
            document.getElementById('weaponDisplay').textContent = wt;
            document.getElementById('healthFill').style.width = `${health}%`;
            const danceBtn = document.getElementById('btn-dance');
            if (danceActive) {
                document.getElementById('danceDisplay').textContent = `ðŸ’ƒ ${Math.ceil(danceTimer)}s`;
                if (danceBtn) danceBtn.style.opacity = '1';
            } else if (danceCooldown > 0) {
                document.getElementById('danceDisplay').textContent = `ðŸ’ƒ ${Math.ceil(danceCooldown)}s`;
                if (danceBtn) { danceBtn.style.opacity = '0.4'; danceBtn.style.filter = 'grayscale(1)'; }
            } else {
                document.getElementById('danceDisplay').textContent = 'ðŸ’ƒ klaar!';
                if (danceBtn) { danceBtn.style.opacity = '1'; danceBtn.style.filter = 'none'; }
            }
        }
        function showGameOver() {
            document.getElementById('finalScore').textContent = `Score: ${score}`;
            document.getElementById('gameOverScreen').classList.add('active');
        }
        function levelUp() {
            level = 2;
            enemies = [];
            showNotification('ðŸŒŸ De storm is voorbij!\nNieuwe wereld bereikt!\nVijanden worden sterker!', 4000);
        }
        canvas.addEventListener('mousemove', e => {
            const rect = canvas.getBoundingClientRect();
            mousePos.x = e.clientX - rect.left;
            mousePos.y = e.clientY - rect.top;
        });
        canvas.addEventListener('click', e => {
            if (gameOver || isDancing || isMobile) return;
            shootAt((mousePos.x + camera.x), (mousePos.y + camera.y));
        });
        if (isMobile) {
            canvas.addEventListener('touchstart', e => {
                if (gameOver || isDancing) return;
                // Don't shoot if a joystick is active (user is using joystick, not tapping to shoot)
                if (joystick.active || joystickRight.active) return;
                const touch = e.touches[0];
                // Ignore taps in the bottom 200px where UI controls live
                if (touch.clientY > window.innerHeight - 200) return;
                const rect = canvas.getBoundingClientRect();
                const scaleX = canvas.width / rect.width;
                const scaleY = canvas.height / rect.height;
                const tx = (touch.clientX - rect.left) * scaleX;
                const ty = (touch.clientY - rect.top) * scaleY;
                shootAt(tx + camera.x, ty + camera.y);
            }, { passive: false });
        }
        document.addEventListener('keydown', e => {
            keys[e.key] = true;
            if (e.key === ' ' && !isJumping && !isDancing) { isJumping = true; jumpVelocity = jumpPower; }
            if (e.key === 'e' || e.key === 'E') activateDance();
            if ((e.key === 'r' || e.key === 'R') && gameOver) resetGame();
        });
        document.addEventListener('keyup', e => { keys[e.key] = false; });
        document.getElementById('restartBtn').addEventListener('click', () => resetGame());
        init();
    </script>
</body>
</html>
